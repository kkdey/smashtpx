proc.time() - ptm
num_chunks <- 2^5
splitting_vec <- numeric()
for(k in 1:num_chunks){
splitting_vec <- c(splitting_vec, rep(k, dim(topic_clus$theta)[1]/num_chunks))
}
splitting_vec
num_chunks <- 2^5
theta_vec <- c(topic_clus$theta[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
splitting_vec <- numeric()
for(k in 1:num_chunks){
splitting_vec <- c(splitting_vec, rep(k, length(theta_vec)/num_chunks))
}
splitting_vec
ptm <- proc.time()
num_chunks <- 2^5
theta_vec <- c(topic_clus$theta[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
splitting_vec <- numeric()
for(k in 1:num_chunks){
splitting_vec <- c(splitting_vec, rep(k, length(theta_vec)/num_chunks))
}
theta_smoothed <- matrix(0, dim(topic_clus$theta)[1], dim(topic_clus$theta)[2])
for(k in 1:dim(topic_clus$theta)[2]){
theta_vec <- c(topic_clus$theta[,k], rep(0, 2^13 - length(topic_clus$theta[,1])))
chunks <- split(theta_vec, splitting_vec)
out <- parallel::mclapply(1:length(chunks), function(x) {
adj_chunk <- mean(chunks[[x]])*length(chunks[[x]])
if(adj_chunk < 0.01){
tmp <- as.numeric(chunks[[x]])
}else{
tmp <- smashr::smash.gaus(chunks[[x]], ashparam = list(control=list(maxiter=500)))
tmp [tmp < 0] = 0
tmp <- as.numeric(tmp)
}
return(tmp)
}, mc.cores = parallel::detectCores())
theta_smoothed[,k] <- unlist(out)[1:dim(topic_clus$theta)[1]]
theta_smoothed[,k] <- theta_smoothed[,k]/(sum(theta_smoothed[,k]))
}
plot(theta_smoothed[,1], col=cols1[1], type="l", ylim=c(0, 0.005))
lines(theta_smoothed[,2], col=cols1[2], ylim=c(0, 0.005))
lines(theta_smoothed[,3], col=cols1[3], ylim=c(0, 0.005))
proc.time() - ptm
library(CountClust)
library(smashr)
library(smashtpx)
library(ashr)
library(parallel)
library(maptpx)
library(slam)
rm(list=ls())
library(CountClust)
library(smashr)
library(smashtpx)
library(ashr)
library(parallel)
library(maptpx)
library(slam)
one_gene_data <- get(load("../supplemental/gtex/reads_all_17_37356535_37360980.Robj"))
length(one_gene_data)
reads_table <- as.numeric()
tissue_labels <- as.numeric();
for(m in 1:8){
reads <- one_gene_data[[m]][[2]]
tissue_labels <- c(tissue_labels, rep(m,dim(reads)[1]))
reads_table <- rbind(reads_table, reads);
}
topic_clus <- maptpx::topics(reads_table, K=3, tol = 10)
cols1 <- c(rev(RColorBrewer::brewer.pal(12, "Paired"))[c(3,4,7,8,11,12,5,6,9,10)],
RColorBrewer::brewer.pal(12, "Set3")[c(1,2,5,8,9)],
RColorBrewer::brewer.pal(9, "Set1")[c(9,7)],
RColorBrewer::brewer.pal(8, "Dark2")[c(3,4,8)])
omega <- topic_clus$omega
annotation <- data.frame(
sample_id = paste0("X", c(1:NROW(omega))),
tissue_label = factor(as.character(tissue_labels),
levels=unique(tissue_labels)) )
rownames(omega) <- annotation$sample_id
CountClust::StructureGGplot(omega = omega,
annotation= annotation,
palette = cols1,
yaxis_label = "",
order_sample = FALSE,
split_line = list(split_lwd = .1,
split_col = "white"),
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 5,
axis_label_face="bold"))
plot(topic_clus$theta[,1], col=cols1[1], type="l")
lines(topic_clus$theta[,2], col=cols1[2])
lines(topic_clus$theta[,3], col=cols1[3])
ptm <- proc.time()
theta_vec_1 <- c(topic_clus$theta[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
theta_vec_2 <- c(topic_clus$theta[,2], rep(0, 2^13 - length(topic_clus$theta[,1])))
theta_vec_3 <- c(topic_clus$theta[,3], rep(0, 2^13 - length(topic_clus$theta[,1])))
sm1 <- smashr::smash.gaus(theta_vec_1, ashparam = list(control=list(maxiter=500)))
sm2 <- smashr::smash.gaus(theta_vec_2, ashparam = list(control=list(maxiter=500)))
sm3 <- smashr::smash.gaus(theta_vec_3, ashparam = list(control=list(maxiter=500)))
sm1[sm1 < 0] <- 0
sm2[sm2 < 0] <- 0
sm3[sm3 < 0] <- 0
plot(sm1[1:dim(topic_clus$theta)[1]], col=cols1[1], type="l")
lines(sm2[1:dim(topic_clus$theta)[1]], col=cols1[2])
lines(sm3[1:dim(topic_clus$theta)[1]], col=cols1[3])
proc.time() - ptm
ptm <- proc.time()
num_chunks <- 2^5
theta_vec <- c(topic_clus$theta[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
splitting_vec <- numeric()
for(k in 1:num_chunks){
splitting_vec <- c(splitting_vec, rep(k, length(theta_vec)/num_chunks))
}
theta_smoothed <- matrix(0, dim(topic_clus$theta)[1], dim(topic_clus$theta)[2])
for(k in 1:dim(topic_clus$theta)[2]){
theta_vec <- c(topic_clus$theta[,k], rep(0, 2^13 - length(topic_clus$theta[,1])))
chunks <- split(theta_vec, splitting_vec)
out <- parallel::mclapply(1:length(chunks), function(x) {
adj_chunk <- mean(chunks[[x]])*length(chunks[[x]])
if(adj_chunk < 0.01){
tmp <- as.numeric(chunks[[x]])
}else{
tmp <- smashr::smash.gaus(chunks[[x]],
ashparam=list(control=list(maxiter=500)))
tmp [tmp < 0] = 0
tmp <- as.numeric(tmp)
}
return(tmp)
}, mc.cores = parallel::detectCores())
theta_smoothed[,k] <- as.numeric(unlist(out)[1:dim(topic_clus$theta)[1]])
theta_smoothed[,k] <- theta_smoothed[,k]
}
theta_smoothed
plot(theta_smoothed[,1], col=cols1[1], type="l")
lines(theta_smoothed[,2], col=cols1[2])
lines(theta_smoothed[,3], col=cols1[3])
ptm <- proc.time()
num_chunks <- 2^5
theta_vec <- c(topic_clus$theta[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
splitting_vec <- numeric()
for(k in 1:num_chunks){
splitting_vec <- c(splitting_vec, rep(k, length(theta_vec)/num_chunks))
}
theta_smoothed <- matrix(0, dim(topic_clus$theta)[1], dim(topic_clus$theta)[2])
for(k in 1:dim(topic_clus$theta)[2]){
theta_vec <- c(topic_clus$theta[,k], rep(0, 2^13 - length(topic_clus$theta[,1])))
chunks <- split(theta_vec, splitting_vec)
out <- parallel::mclapply(1:length(chunks), function(x) {
adj_chunk <- mean(chunks[[x]])*length(chunks[[x]])
if(adj_chunk < 0.01){
tmp <- as.numeric(chunks[[x]])
}else{
tmp <- smashr::smash.gaus(chunks[[x]])
tmp [tmp < 0] = 0
tmp <- as.numeric(tmp)
}
return(tmp)
}, mc.cores = parallel::detectCores())
theta_smoothed[,k] <- as.numeric(unlist(out)[1:dim(topic_clus$theta)[1]])
theta_smoothed[,k] <- theta_smoothed[,k]
}
plot(theta_smoothed[,1], col=cols1[1], type="l")
lines(theta_smoothed[,2], col=cols1[2])
lines(theta_smoothed[,3], col=cols1[3])
proc.time() - ptm
ptm <- proc.time()
num_chunks <- 2^5
theta_vec <- c(topic_clus$theta[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
splitting_vec <- numeric()
for(k in 1:num_chunks){
splitting_vec <- c(splitting_vec, rep(k, length(theta_vec)/num_chunks))
}
theta_smoothed <- matrix(0, dim(topic_clus$theta)[1], dim(topic_clus$theta)[2])
for(k in 1:dim(topic_clus$theta)[2]){
theta_vec <- c(topic_clus$theta[,k], rep(0, 2^13 - length(topic_clus$theta[,1])))
chunks <- split(theta_vec, splitting_vec)
out <- parallel::mclapply(1:length(chunks), function(x) {
adj_chunk <- mean(chunks[[x]])*length(chunks[[x]])
if(adj_chunk < 0.01){
tmp <- as.numeric(chunks[[x]])
}else{
tmp <- smashr::smash.gaus(chunks[[x]])
tmp [tmp < 0] = 0
tmp <- as.numeric(tmp)
}
return(tmp)
}, mc.cores = parallel::detectCores())
theta_smoothed[,k] <- as.numeric(unlist(out)[1:dim(topic_clus$theta)[1]])
theta_smoothed[,k] <- theta_smoothed[,k]/sum(theta_smoothed[,k])
}
plot(theta_smoothed[,1], col=cols1[1], type="l")
lines(theta_smoothed[,2], col=cols1[2])
lines(theta_smoothed[,3], col=cols1[3])
proc.time() - ptm
one_gene_data <- get(load("../supplemental/gtex/reads_all_17_37356535_37360980.Robj"))
length(one_gene_data)
reads_table <- as.numeric()
tissue_labels <- as.numeric();
for(m in 1:8){
reads <- one_gene_data[[m]][[2]]
tissue_labels <- c(tissue_labels, rep(m,dim(reads)[1]))
reads_table <- rbind(reads_table, reads);
}
row_total <- rowSums(reads_table)
row_total
ptm <- proc.time()
z_leaf_est_1 <- round(sweep(topic_clus$theta[,1], MARGIN=2, colSums(sweep(topic_clus$omega, MARGIN = 1, row_total, "*")), "*"));
topic_clus$omega
length(row_total)
dim(topic_clus$omega)
colSums(sweep(topic_clus$omega, MARGIN = 1, row_total, "*"))
z_leaf_est_1 <- round(sweep(topic_clus$theta, MARGIN=2, colSums(sweep(topic_clus$omega, MARGIN = 1, row_total, "*")), "*"));
z_leaf_est_1 <- round(sweep(topic_clus$theta[1,], MARGIN=2, colSums(sweep(topic_clus$omega, MARGIN = 1, row_total, "*")), "*"));
z_leaf_est <- round(sweep(topic_clus$theta, MARGIN=2, colSums(sweep(topic_clus$omega, MARGIN = 1, row_total, "*")), "*"));
dim(z_leaf_est)
ptm <- proc.time()
z_leaf_est <- round(sweep(topic_clus$theta, MARGIN=2, colSums(sweep(topic_clus$omega, MARGIN = 1, row_total, "*")), "*"));
z_vec_1 <- c(z_leaf_est[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
z_vec_2 <- c(z_leaf_est[,2], rep(0, 2^13 - length(topic_clus$theta[,1])))
z_vec_3 <- c(z_leaf_est[,3], rep(0, 2^13 - length(topic_clus$theta[,1])))
sm1 <- smashr::smash.poiss(z_vec_1)
sm2 <- smashr::smash.poiss(z_vec_2)
sm3 <- smashr::smash.poiss(z_vec_3)
sm1 <- sm1/sum(s1)
sm2 <- sm2/sum(s2)
sm3 <- sm3/sum(s3)
plot(sm1[1:dim(topic_clus$theta)[1]], col=cols1[1], type="l")
lines(sm2[1:dim(topic_clus$theta)[1]], col=cols1[2])
lines(sm3[1:dim(topic_clus$theta)[1]], col=cols1[3])
proc.time() - ptm
ptm <- proc.time()
num_chunks <- 2^5
theta_vec <- c(topic_clus$theta[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
splitting_vec <- numeric()
for(k in 1:num_chunks){
splitting_vec <- c(splitting_vec, rep(k, length(theta_vec)/num_chunks))
}
theta_smoothed <- matrix(0, dim(topic_clus$theta)[1], dim(topic_clus$theta)[2])
z_leaf_est <- round(sweep(topic_clus$theta, MARGIN=2, colSums(sweep(topic_clus$omega, MARGIN = 1, row_total, "*")), "*"));
for(k in 1:dim(topic_clus$theta)[2]){
z_vec <- c(z_leaf_est[,k], rep(0, 2^13 - length(topic_clus$theta[,1])))
chunks <- split(z_vec, splitting_vec)
out <- parallel::mclapply(1:length(chunks), function(x) {
adj_chunk <- mean(chunks[[x]])*length(chunks[[x]])
if(adj_chunk < 0.01){
tmp <- as.numeric(chunks[[x]])
}else{
tmp <- smashr::smash.poiss(chunks[[x]])
tmp [tmp < 0] = 0
tmp <- as.numeric(tmp)
}
return(tmp)
}, mc.cores = parallel::detectCores())
theta_smoothed[,k] <- as.numeric(unlist(out)[1:dim(topic_clus$theta)[1]])
theta_smoothed[,k] <- theta_smoothed[,k]/sum(theta_smoothed[,k])
}
plot(theta_smoothed[,1], col=cols1[1], type="l")
lines(theta_smoothed[,2], col=cols1[2])
lines(theta_smoothed[,3], col=cols1[3])
proc.time() - ptm
topic_clus <- smash.topics(reads_table,
K=3, tol = 100,
smooth_gap=20,
smash_method = "poisson",
init.method = "kmeans")
save(topic_clus, file="smashtpx_fit.rda")
source('~/Documents/smashtpx/R/smash.topics.R')
source('~/Documents/smashtpx/R/smash.tpx.R')
library(smashtpx)
topic_clus <- smash.topics(reads_table,
K=3, tol = 100,
smooth_gap=20,
smash_method = "poisson",
init.method = "kmeans")
save(topic_clus, file="smashtpx_fit.rda")
topic_clus <- get(load("smashtpx_fit.rda"))
omega <- topic_clus$omega
annotation <- data.frame(
sample_id = paste0("X", c(1:NROW(omega))),
tissue_label = factor(as.character(tissue_labels),
levels=unique(tissue_labels)) )
rownames(omega) <- annotation$sample_id
cols1 <- c(rev(RColorBrewer::brewer.pal(12, "Paired"))[c(3,4,7,8,11,12,5,6,9,10)],
RColorBrewer::brewer.pal(12, "Set3")[c(1,2,5,8,9)],
RColorBrewer::brewer.pal(9, "Set1")[c(9,7)],
RColorBrewer::brewer.pal(8, "Dark2")[c(3,4,8)])
CountClust::StructureGGplot(omega = omega,
annotation= annotation,
palette = cols1,
yaxis_label = "",
order_sample = FALSE,
split_line = list(split_lwd = .1,
split_col = "white"),
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 5,
axis_label_face="bold"))
plot(topic_clus$theta[,1], col=cols1[1], type="l")
lines(topic_clus$theta[,2], col=cols1[2])
lines(topic_clus$theta[,3], col=cols1[3])
topic_clus <- smash.topics(reads_table,
K=3, tol = 100,
smooth_gap=20,
smash_method = "poisson",
init.method = "kmeans")
save(topic_clus, file="smashtpx_sim_fit_poisson.rda")
topic_clus <- get(load("smashtpx_sim_fit_poisson.rda"))
omega <- topic_clus$omega
annotation <- data.frame(
sample_id = paste0("X", c(1:NROW(omega))),
tissue_label = factor(as.character(tissue_labels),
levels=unique(tissue_labels)) )
rownames(omega) <- annotation$sample_id
cols1 <- c(rev(RColorBrewer::brewer.pal(12, "Paired"))[c(3,4,7,8,11,12,5,6,9,10)],
RColorBrewer::brewer.pal(12, "Set3")[c(1,2,5,8,9)],
RColorBrewer::brewer.pal(9, "Set1")[c(9,7)],
RColorBrewer::brewer.pal(8, "Dark2")[c(3,4,8)])
CountClust::StructureGGplot(omega = omega,
annotation= annotation,
palette = cols1,
yaxis_label = "",
order_sample = FALSE,
split_line = list(split_lwd = .1,
split_col = "white"),
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 5,
axis_label_face="bold"))
plot(topic_clus$theta[,1], col=cols1[1], type="l")
lines(topic_clus$theta[,2], col=cols1[2])
lines(topic_clus$theta[,3], col=cols1[3])
topic_clus <- smash.topics(reads_table,
K=3, tol = 100,
smooth_gap=20,
smash_method = "gaussian",
init.method = "kmeans")
save(topic_clus, file="smashtpx_sim_fit_gaussian.rda")
topic_clus <- get(load("smashtpx_sim_fit_poisson.rda"))
omega <- topic_clus$omega
annotation <- data.frame(
sample_id = paste0("X", c(1:NROW(omega))),
tissue_label = factor(as.character(tissue_labels),
levels=unique(tissue_labels)) )
rownames(omega) <- annotation$sample_id
cols1 <- c(rev(RColorBrewer::brewer.pal(12, "Paired"))[c(3,4,7,8,11,12,5,6,9,10)],
RColorBrewer::brewer.pal(12, "Set3")[c(1,2,5,8,9)],
RColorBrewer::brewer.pal(9, "Set1")[c(9,7)],
RColorBrewer::brewer.pal(8, "Dark2")[c(3,4,8)])
CountClust::StructureGGplot(omega = omega,
annotation= annotation,
palette = cols1,
yaxis_label = "",
order_sample = FALSE,
split_line = list(split_lwd = .1,
split_col = "white"),
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 5,
axis_label_face="bold"))
plot(topic_clus$theta[,1], col=cols1[1], type="l")
lines(topic_clus$theta[,2], col=cols1[2])
lines(topic_clus$theta[,3], col=cols1[3])
topic_clus <- smash.topics(reads_table,
K=3, tol = 100,
smooth_gap=20,
smash_method = "poisson",
init.method = "taddy")
save(topic_clus, file="smashtpx_sim_fit_poisson_taddy.rda")
topic_clus <- get(load("smashtpx_sim_fit_gaussian.rda"))
omega <- topic_clus$omega
annotation <- data.frame(
sample_id = paste0("X", c(1:NROW(omega))),
tissue_label = factor(as.character(tissue_labels),
levels=unique(tissue_labels)) )
rownames(omega) <- annotation$sample_id
cols1 <- c(rev(RColorBrewer::brewer.pal(12, "Paired"))[c(3,4,7,8,11,12,5,6,9,10)],
RColorBrewer::brewer.pal(12, "Set3")[c(1,2,5,8,9)],
RColorBrewer::brewer.pal(9, "Set1")[c(9,7)],
RColorBrewer::brewer.pal(8, "Dark2")[c(3,4,8)])
CountClust::StructureGGplot(omega = omega,
annotation= annotation,
palette = cols1,
yaxis_label = "",
order_sample = FALSE,
split_line = list(split_lwd = .1,
split_col = "white"),
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 5,
axis_label_face="bold"))
plot(topic_clus$theta[,1], col=cols1[1], type="l")
lines(topic_clus$theta[,2], col=cols1[2])
lines(topic_clus$theta[,3], col=cols1[3])
topic_clus <- get(load("smashtpx_sim_fit_poisson_taddy.rda"))
omega <- topic_clus$omega
annotation <- data.frame(
sample_id = paste0("X", c(1:NROW(omega))),
tissue_label = factor(as.character(tissue_labels),
levels=unique(tissue_labels)) )
rownames(omega) <- annotation$sample_id
cols1 <- c(rev(RColorBrewer::brewer.pal(12, "Paired"))[c(3,4,7,8,11,12,5,6,9,10)],
RColorBrewer::brewer.pal(12, "Set3")[c(1,2,5,8,9)],
RColorBrewer::brewer.pal(9, "Set1")[c(9,7)],
RColorBrewer::brewer.pal(8, "Dark2")[c(3,4,8)])
CountClust::StructureGGplot(omega = omega,
annotation= annotation,
palette = cols1,
yaxis_label = "",
order_sample = FALSE,
split_line = list(split_lwd = .1,
split_col = "white"),
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 5,
axis_label_face="bold"))
plot(topic_clus$theta[,1], col=cols1[1], type="l")
lines(topic_clus$theta[,2], col=cols1[2])
lines(topic_clus$theta[,3], col=cols1[3])
topic_clus <- smash.topics(reads_table,
K=3, tol = 100,
smooth_gap=20,
smash_method = "gaussian",
init.method = "taddy")
topic_clus <- get(load("smashtpx_sim_fit_gaussian_taddy.rda"))
omega <- topic_clus$omega
annotation <- data.frame(
sample_id = paste0("X", c(1:NROW(omega))),
tissue_label = factor(as.character(tissue_labels),
levels=unique(tissue_labels)) )
rownames(omega) <- annotation$sample_id
cols1 <- c(rev(RColorBrewer::brewer.pal(12, "Paired"))[c(3,4,7,8,11,12,5,6,9,10)],
RColorBrewer::brewer.pal(12, "Set3")[c(1,2,5,8,9)],
RColorBrewer::brewer.pal(9, "Set1")[c(9,7)],
RColorBrewer::brewer.pal(8, "Dark2")[c(3,4,8)])
CountClust::StructureGGplot(omega = omega,
annotation= annotation,
palette = cols1,
yaxis_label = "",
order_sample = FALSE,
split_line = list(split_lwd = .1,
split_col = "white"),
axis_tick = list(axis_ticks_length = .1,
axis_ticks_lwd_y = .1,
axis_ticks_lwd_x = .1,
axis_label_size = 5,
axis_label_face="bold"))
plot(topic_clus$theta[,1], col=cols1[1], type="l")
lines(topic_clus$theta[,2], col=cols1[2])
lines(topic_clus$theta[,3], col=cols1[3])
save(topic_clus, file="smashtpx_sim_fit_gaussian_taddy.rda")
150/(53*26)
307/(53*26)
293/(53*26)
1 - 0.21
library(CountClust)
library(smashr)
library(smashtpx)
library(ashr)
library(parallel)
library(maptpx)
library(slam)
one_gene_data <- get(load("../supplemental/gtex/reads_all_17_37356535_37360980.Robj"))
length(one_gene_data)
reads_table <- as.numeric()
tissue_labels <- as.numeric();
for(m in 1:8){
reads <- one_gene_data[[m]][[2]]
tissue_labels <- c(tissue_labels, rep(m,dim(reads)[1]))
reads_table <- rbind(reads_table, reads);
}
row_total <- rowSums(reads_table)
topic_clus <- maptpx::topics(reads_table, K=3, tol = 10)
ptm <- proc.time()
num_chunks <- 2^5
theta_vec <- c(topic_clus$theta[,1], rep(0, 2^13 - length(topic_clus$theta[,1])))
splitting_vec <- numeric()
for(k in 1:num_chunks){
splitting_vec <- c(splitting_vec, rep(k, length(theta_vec)/num_chunks))
}
theta_smoothed <- matrix(0, dim(topic_clus$theta)[1], dim(topic_clus$theta)[2])
z_leaf_est <- round(sweep(topic_clus$theta, MARGIN=2, colSums(sweep(topic_clus$omega, MARGIN = 1, row_total, "*")), "*"));
k <- 1
z_vec <- c(z_leaf_est[,k], rep(0, 2^13 - length(topic_clus$theta[,1])))
chunks <- split(z_vec, splitting_vec)
chunks[[1]]
chunks[[2]]
plot(chunks[[1]], type="l", col="red")
plot(reads_table[1,], type="l", col="red")
reads_table[1,1:1000]
reads_table[1,1:1300]
reads_table[1,1:1500]
reads_table[2,1:1500]
plot(reads_table[1,1:1000], type="l", col="red")
lines(reads_table[2,1:1000], col="blue")
plot(reads_table[1,900:1000], reads_table[2,900:1000])
plot(reads_table[3,900:1000], reads_table[2,900:1000])
library(CountClust)
library(smashr)
library(smashtpx)
library(ashr)
library(parallel)
library(maptpx)
library(slam)
library(REBayes)
install.packages("REBayes")
library(Rmosek)
